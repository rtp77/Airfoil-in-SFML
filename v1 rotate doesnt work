#include<SFML/Graphics.hpp>

#include<iostream>
#include<math.h>
#include "imgui.h"
#include "imgui-SFML.h"

int main(int argc, char** argv[]) {
	sf::RenderWindow window(sf::VideoMode(1200, 800), "Airfoil");
	ImGui::SFML::Init(window);

	bool start = false, spoiler = false;
	int flap = 0, aileron = 0;
	int adjustx = 100, adjusty = 400;
	
	
	float arr[35][2] = { {500,0.65},{475,5.7},{450,10.4},{400,18.75},{350,25.9},{300,31.8},{250,36.2},{200,39},{150,39.4},{125,38.35},{100,36.3},{75,33.05},{50,28.15},{37.5,24.8},{25,20.65},{12.5,14.95},{6.25,10.75},{0,0},{6.25,-8.25},{12.5,-11.35},{25,-15.05},{37.5,-17.3},{50,-18.75},{75,-20.5},{100,-21.15},{125,-21.1},{150,-20.6},{200,-19},{250,-16.7},{300,-13.8},{350,-10.7},{400,-7.5},{450,-4.1},{475,-2.4},{500,-0.65} };

	float Actualarr[35][2] = { {500,0.65},{475,5.7},{450,10.4},{400,18.75},{350,25.9},{300,31.8},{250,36.2},{200,39},{150,39.4},{125,38.35},{100,36.3},{75,33.05},{50,28.15},{37.5,24.8},{25,20.65},{12.5,14.95},{6.25,10.75},{0,0},{6.25,-8.25},{12.5,-11.35},{25,-15.05},{37.5,-17.3},{50,-18.75},{75,-20.5},{100,-21.15},{125,-21.1},{150,-20.6},{200,-19},{250,-16.7},{300,-13.8},{350,-10.7},{400,-7.5},{450,-4.1},{475,-2.4},{500,-0.65} };

	sf::VertexArray path(sf::LinesStrip, 35);


	sf::Color c = sf::Color::Black;

	//initial positioning
	for (int i = 0; i < 35; i++) {
		path[i].position = sf::Vector2f(arr[i][0]+adjustx,-arr[i][1]+adjusty);
		path[i].color = c;
		Actualarr[i][0] = arr[i][0] +adjustx;
		Actualarr[i][1] = -arr[i][1] +adjusty;
	}

	float initialSize = 0;
	float actualSize = 0;

	float initialRotate = 0;
	float actualRotate = 0;

	sf::Clock deltaClock;
	while (window.isOpen()) {
		sf::Event e;
		while (window.pollEvent(e)) {
			ImGui::SFML::ProcessEvent(e);
			if (e.type == sf::Event::Closed) {
				window.close();
			}
			//Size Change
			if (initialSize != actualSize){
				for (int i = 0; i < 35; i++) {
					path[i].position = sf::Vector2f(arr[i][0]*(actualSize) + adjustx, -arr[i][1]*(actualSize)+ adjusty);
					path[i].color = c;
					initialSize = actualSize;
					Actualarr[i][0] = arr[i][0] * (actualSize)+adjustx;
					Actualarr[i][1] = -arr[i][1] * (actualSize)+adjusty;
				}
			}
			//Rotate Change
			if (initialRotate != actualRotate) {
				for (int i = 0; i < 35; i++) {
					int InitialX = Actualarr[i][0];
					int InitialY = Actualarr[i][1];
					std::cout << "Initialx is " << InitialX << " and Initialy is " << InitialY << std::endl;
					int InitialHypo = sqrt(InitialX * InitialX + InitialY * InitialY);
					std::cout << "Hypotenuse is " << InitialHypo << std::endl;
					std::cout << "Rotation is " << actualRotate << std::endl;
					int NewY = sin(actualRotate*0.0174533) * InitialHypo * 0.2;
					int NewX = cos(actualRotate*0.0174533) * InitialHypo * 0.2;
					std::cout << "NewX is " << NewX << " and NewY is " << NewY <<"\n\n"<<std::endl;
					path[i].position = sf::Vector2f(InitialX + NewX - adjustx, InitialY + NewY);
				}
				initialRotate = actualRotate;
			}
			


		}//pollevent 

		ImGui::SFML::Update(window, deltaClock.restart());

		
		


		ImGui::Begin("Lap Simulation");
		ImGui::Text("Lap Simulation");

		ImGui::Checkbox("Begin", &start);
		ImGui::SliderFloat("Size", &actualSize, 1, 2);
		ImGui::SliderFloat("Rotate", &actualRotate, -50, 50);
		ImGui::End();



		window.clear(sf::Color::White);

		window.draw(path);

		ImGui::SFML::Render(window);
		window.display();
	}

	ImGui::SFML::Shutdown();
	return 0;
}
